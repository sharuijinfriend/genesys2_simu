sd卡中存放两张4096*4096图像，然后经过采样，在1920*1080的分辨率下VGA输出得到1024*1024的图案，两张图片循环显示
此时sd卡中存放了4张1024*1024*16的图片，之后再存放了两张4096*4096*16bit的图片。如果后人需要用的话，可能要改一下sd模块中的读起始地址。

这个版本的新增功能为，交替读出两路数据，一路数据是vga显示采样显示1024*1024图像，另一路数据是完整的4096*4096*2*16bit的数据。
增加了uart的串口功能，就在ddrtovga_top.v的下面，不过最后没有使用，可以看到fifo_data_full的读出使能并不是由uart模块提供的。因为uart读出速度太慢，而且PAC端的调试软件有问题，
接收的数据多一点的话就会卡死，所以最后放弃这种输出方式。

最后采用的数据验证方法是，在ila核中利用capture核trigger功能，trigger有两个条件，一个是ddr_data_addr，一个是ddr3读出的valid==1，capture有一个条件
，ddr3读出的valid==1.读出后保存为csv文件，利用verify中的python脚本进行比较，将结果输出到html文件中。我利用这个办法验证了5*32万byte的数据。图片的二进制文件
生成需要使用generatebin.m的matlab文件。

在给FMC接口输出分配引脚的时候，DRC检查提示同一个bank的电压要相同，因此所有的switch上的电压由LVCMOS33改为LVCMOS12。事实上官方的引脚分配也是LVCMOS12,我之前的引脚分配是不对的。

目前fmc输出的数据为16位，加上了行、场消隐信号，以及一位表示输出哪张图片，以及一个时钟。随数据一起的发送的时钟相位要比
输出数据所用时钟要晚200°。经过测试180°和225°都会存在错误，所以实际上可用的采样时间段非常短。
1.线延迟非常大，接近一个时钟周期。
2.线间存在串扰，因此在数据到达之后还需要一定时间使得受到串扰影响的数据能被驱动回正确的值。

#2019/11/13
把同样的东西移植到接收版上，加上一个256bit转16bit的程序，输出到一个16位的fifo中。令一路是
从fmc接收16bit数据，然后缓存在一个位宽为16位的fifo，最后从这两个fifo中读出数据，进行比较，
用一个计数器统计不同的次数。至于计数器的值可以用在线硬件分析仪、uart、oled看。我比较倾向于
后者，当然难度也是最大的。

